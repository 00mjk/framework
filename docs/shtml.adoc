= Binding Forms and Function Callbacks to HTML

Lift's approach to binding forms is different from many other frameworks. In
Lift, you bind form elements to callback functions that process their values.
You can even bind event callbacks to arbitrary server-side callback functions.
The `SHtml` object provides this functionality.

== Simple Example

Here's a simple login form bound to some server-side callbacks:

.Simple Login Form
====
```html
<form data-lift="Form.bind">
  <ul>
    <li>
      <label>Username: <input id="username"></label>
    </li>
    <li>
      <label>Password: <input id="password" type="password"></label>
    </li>

    <li>
      <button type="submit">Submit</button>
    </li>
  </ul>
</form>
```

```scala
class Form {
  def bind = {
    var username: Box[String] = Empty
    var password: Box[String] = Empty

    def processLogin = {
      println(s"Got $username and $password!")
    }

    c"#username" #> handler({ input => username = Full(input) }) &
    c"#password" #> handler({ input => password = Full(input) }) &
    c"form" #> handler(processLogin _)
  }
}
```
====

If we run this template, we'll see the `name` attributes have been mangled in
our `input` elements. These are generated by a secure pseudo-random number
generator and associated with the functions we've defined on the server. Amongst
other things, this helps harden your application against cross-site request
forgery attacks. The end result looks something like (though not exactly) this:

```html
<form action="/lift/form/F758907123099">
  <ul>
    <li>
      <label>Username: <input name="F758907123098"></label>
    </li>
    <li>
      <label>Password: <input name="F123098670129" type="password"></label>
    </li>

    <li>
      <button type="submit">Submit</button>
    </li>
  </ul>
</form>
```

The action on the form points to a URI that will trigger the callback for the
form bound above. That callback is guaranteed to be triggered last, so you can
handle the results of the full submission there. Like the `name` attributes, the
path is generated by a secure PRNG and helps harden your application against
cross-site request forgery and other attacks.

== AJAX Handlers

The examples above are all functions that return `Unit`. This means the form is
expected to be submitted via a regular page change. If you want to submit your
form via AJAX, simply call `ajaxHandler` instead, and return a `JsCmd`, which is
Lift's typed representation of JavaScript. We can rewrite the above snippet:

.AJAX Login Form
====
```scala
class Form {
  var username: Box[String] = Empty
  var password: Box[String] = Empty

  private def processLogin = {
    println(s"Got $username and $password!")

    Alert("Processed!")
  }

  def bind = {
    c"#username" #> handler({ input => username = Full(input) }) &
    c"#password" #> handler({ input => password = Full(input) }) &
    c"form" #> ajaxHandler(processLogin _)
  }
}
```
====

Because our form's handler is now an AJAX handler, Lift will automatically make
the form submit via AJAX. Note that you don't need to change your field handlers;
these will be invoked as expected.

== AJAX Event Handlers

In addition to the above, you can attach AJAX event handlers to any form element.
Let's say we wanted to verify a username was valid while the user was filling in
the password. To do this, we could set up the form as follows:

.AJAX Login Form
====
```scala
class Form {
  var username: Box[String] = Empty
  var password: Box[String] = Empty

  def verifyUsername(username: String) = {
    if (username.isEmpty)
      DispatchEvent("#username", "invalid", "Username should not be empty")
    else
      Noop
  }

  private def processLogin = {
    println(s"Got $username and $password!")

    Alert("Processed!")
  }
  def bind = {
    c"#username" #> handler({ input => username = Full(input) }) &
    c"#username [onchange]" #> ajaxHandler(verifyUsername _) &
    c"#password" #> handler({ input => password = Full(input) }) &
    c"form" #> ajaxHandler(processLogin _)
  }
}
```
====

Above, we make use of another Lift JavaScript helper to dispatch the event
`invalid` on the username element with a message. We bind it to the element's
`change` event, which means it will fire when the user blurs the element.
While constructing the page, Lift automatically renders the JavaScript as a
separate JS file that is applied quickly after page load. This is another
security precaution to avoid inline scripts in the page, and helps ensure you
can use strong `Content-Security-Policy` settings (see more in the [Lift
Security Guide]).

== Simplified Handler Binding

The above samples were done by directly calling `SHtml.handler` and
`SHtml.ajaxHandler`; however, Lift also supports implicitly creating the
handlers by simply binding to a function directly.

.Simplified Binding for AJAX Login Form
====
```scala
class Form {
  var username: Box[String] = Empty
  var password: Box[String] = Empty

  def verifyUsername(username: String) = {
    if (username.isEmpty)
      DispatchEvent("#username", "invalid", "Username should not be empty")
    else
      Noop
  }

  private def processLogin = {
    println(s"Got $username and $password!")

    Alert("Processed!")
  }
  def bind = {
    c"#username" #> { input => username = Full(input) } &
    c"#username [onchange]" #> verifyUsername _ &
    c"#password" #> { input => password = Full(input) } &
    c"form" #> processLogin _
  }
}
```
====

Above, we've gotten rid of explicit calls to `handler` and `ajaxHandler`.
Instead, because `verifyUsername` and `processLogin` return `JsCmd`, Lift
binds those as AJAX handlers, and the other handlers are bound as regular form
handlers.


