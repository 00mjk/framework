:idprefix:
:idseparator: -
:toc: right
:toclevels: 2

= CSS Selector Transforms

Lift's templating strategy is much simpler than most systems, and is aimed at
cleanly and completely separating business logic from markup. Many a framework
has made this claim, but Lift is one of the few to have achieved this break
completely, using only HTML annotations with `data-` attributes. You can find
an overview of the full Lift CSS templating strategy in the [Lift templating
guide]().

This document is a reference on the underpinnings of Lift templating, the CSS
Selector Transforms. These are used in Lift code to transform a block of HTML
by enriching it with data from the system and filtering it based on business
rules.

== Selectors and Replacement Rules

CSS Selector Transforms consist of three main components:
 - The selector
 - The subnode modification rule
 - The transformation function

///
  Nice to have: graphic that shows a selector transform pointing to each
///

The details of each are provided below, but first here ere are some simple
examples of transforms that you can write with links:

.Replace the contents of all `a` elements with the text "Mozilla"
====
```scala
"a *" #> "Mozilla"
```
====

.Make all links point to Mozilla
====
```scala
"a [href]" #> "http://mozilla.org"
```
====

.Replace all elements with class `name` with a user's name
====
```scala
".name" #> user.name
```
====

.Do all three of the previous things at once
====
"a *" #> "Mozilla" &
"a [href]" #> "http://mozilla.org" &
".name" #> user.name
====

These examples show a few options:
 - You can select by element name or by class name. More available selectors are
   in the section below on <<available-selectors>>.
 - You can set the body of an element, an attribute of an element, or even
   replace the element altogether. More subnode modification rules are in the
   section below on <<available-modification-rules>>.
 - You can combine multiple CSS selector transforms using the `&` operator. This
   is subject to some limitations detailed in the section below on <<combining-selectors-and-transforms>>.

== Available Selectors

NOTE: You cannot chain these in the standard CSS way (e.g., `input.class-name` is not
valid). Instead, you must always put spaces between the selectors. More on this
in the section below on <<combining-selectors-and-transforms>>.

Class selector: `.class-name`::
  The class selector matches any element that has `class-name` as one of its
  classes. For example, you can use `.item` to match an element `<li
  class="item selected">...</li>`.

Id selector: `#element-id`::
  The id selector matches any element that has `element-id` as the value of its
  `id` attribute. For example, you can use `#page-header` to match an element
  `<header id="page-header">...</header>`.

Name selector: `@field-name`::
  The name selector matches any element that has `field-name` as the value of
  its `name` attribute. For example, you can use `@username` to match an element
  `<input name="username">`.

Element selector: `element-name`::
  The element selector matches any element of type `element-name`. For example,
  you can use `input` to match an element `<input type="text">`.

Attribute selector: `an-attribute=a-value`::
  The attribute selector matches any element whose attribute named
  `an-attribute` has the value `a-value`. For example, you can use
  `ng-model=user` to match an element `<ul ng-model="user">...</ul>`.

Universal selector: `*`::
  The universal selector matches any element.

Root selector: `^`::
  The root selector matches elements at the root level of the NodeSeq being
  transformed. For example, you can use `^` to match both the `header`
  and `ul` elements in the HTML `<header id="page-header">...</header><ul
  ng-model="user">...</ul>`.

=== Shortened Attribute Selectors

In addition to the above base selectors, a few selectors are provided that are
useful shortcuts for special attributes:

Data name attribute selector: `;name-data`::
  The data name attribute selector matches any element that has `name-data` as
  the value of its `data-name` attribute. For example, you can use `;user-info`
  to match an element `<ul data-name="user-info">...</ul>`.

Field type selectors: `:button`, `:checkbox`, `:file`, `:password`, `:radio`, `:reset`, `:submit`, `:text`::
  The field type selectors match elements whose `type` attribute is set to a
  particular type. For example, `:button` will match an element `<input
  type="button">`. `:checkbox` will match an element `<input
  type="checkbox">`. Note that this is _not_ generalized. So, for example,
  `:custom-field` will _not_ match `<input type="custom-field">`. Only the above
  values are supported.

== Available Modification Rules

Subnode modification rules indicate what the result of the transformation
function will do to the element matched by the selector.

Set children rule: `*`::
  The transformation result will set the children of the matched element(s). For
  example, `^ *` will set the children of all root elements to the results of
  the transformation.

Append to children rule: `*<` or `*+`::
  The transformation result will be appended to the children of the matched
  element(s). For example, `^ *+` will append the results of the transformation
  to the end of the content of all root elements.

Prepend to children rule: `>*` or `-*`::
  The transformation result will be prepended to the children of the matched
  element(s). For example, `^ *+` will prepend the results of the transformation
  to the beginning of the content of all root elements.

Surround children rule: `<*>`::
  The transformation result will produce a single element, whose children will
  be set to the children of the matched element(s). For example, `^ <*>` will
  take the element produced by the transformation function and copy it once for
  every root element, wrapping the new element around the children of the root
  elements.

Set attribute rule: `[attribute-name]`::
  The attribute with name `attribute-name` on the matched element will have its
  value set to the transformation result. For example, `^ [data-user-id]` will
  set the `data-user-id` attribute of all root elements to the transformation
  result.

Append to attribute rule: `[attribute-name+]`::
  The transformation result will be appended to the end of the value of the
  attribute with name `attribute-name` on the matched element with a prepended
  space. For example, `^ [class+]` will append a space and then the
  transformation result to the `class` attribute of all root elements.

Remove from attribute rule: `[attribute-name!]`::
  The transformation result will be filtered from the value of the attribute
  with name `attribute-name` on the matched element, provided it can be found on
  its own separated by a space. For example, `^ [class!]` will remove the
  class named by the transformation result from all root elements.

Don't merge attributes rule: `!!`::
  By default, if the transformation yields a single element and the element
  matched by the selector is being replaced by that result, the attributes from
  the matched element are merged into the attributes of the transformation's
  element. This modifier prevents that from happening. For example, by default
  doing `"input" #> <div />` and applying it to `<input type="text">` would
  yield `<div type="text" />`. Doing `"input !!" #> <div />` would instead yield
  `<div />`.

Lift node rule: `^^`::
  This rule will lift the first selected element all the way to the root of the
  `NodeSeq` it's being applied to. Note that the transformation result is
  irrelevant in this case. Additionally, note that this only applies to the
  _first_ element that matches the selector, and that it lifts it all the way to
  the root of the `NodeSeq` being transformed. For example,
  `".admin-user ^^" #> "ignored"`, when applied to the
  markup `<div><form><fieldset class=".admin-user">...</fieldset>
  <fieldset class="power-user">...</fieldset></div>`, will
  produce `<fieldset class="admin-user">...</fieldset>`. This is useful for
  selecting among a set of template elements based on some external condition
  (e.g., one template for one type of user, another template for another type of
  user, etc).

Lift node's children rule: `^*`::
  This rule will lift the _children_ of the first selected element all the way
  to the root of the `NodeSeq` it's being applied to. As above, the
  transformation result is irrelevant, only the _first_ matched element's
  children are lifted, and the children are lifted all the way to the root of
  the `NodeSeq` being transformed. For example, `"#power-user ^*" #> "ignored"`,
  when applied to the markup
  `<section id="admin-user"><h3>Admin</h3></section>
  <section id="power-user"><h3>Power User</h3></section>`,
  will produce `<h3>Power User</h3>`.

== Transformation Functions

== Combining Selectors and Transforms

Lift's selectors are not identical to CSS selectors. They're designed for speed
rather than for being featureful, and designed in the context of a full-featured
language rather than a limited language like CSS. One key difference is in how
you combine them. In CSS, you can use `>` to select direct children, `+` for
direct siblings, etc. Lift only provides one combinator, the space: ` `. It
works just like in CSS, applying to all descendants. Com

== Macros and Strings

Lift's CSS Selector Transforms can be used in two modes. Most basically, you
can create a `String` with the appropriate selector and then specify the
transformation you want to apply to matching blocks
