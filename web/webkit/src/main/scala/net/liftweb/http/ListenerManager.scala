/*
 * Copyright 2007-2015 WorldWide Conferencing, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.liftweb
package http

import actor._
import common._

/**
 * This is a message class for use with `[[ListenerManager]]` and
 * `[[CometListener]]` instances. The use of the `[[shouldUpdate]]` function is
 * deprecated, and should instead be handled by the message processing partial
 * functions on the `CometListener` instances themselves.
 *
 * Send this message to a `ListenerManager` to indicate that you want to add a
 * listener to it.
 */
case class AddAListener(who: SimpleActor[Any], shouldUpdate: PartialFunction[Any, Boolean])
object AddAListener {
  def apply(who: SimpleActor[Any]) = new AddAListener(who, {
    case _ => true
  })
}

/**
 * This is a message class for use with `[[ListenerManager]]` and
 * `[[CometListener]]` instances.
 *
 * Send this message to a `ListenerManager` to indicate that you want to remove
 * a listener from it.
 */
case class RemoveAListener(who: SimpleActor[Any])

/**
 * This trait manages a set of `LiftActor`s in a publish/subscribe pattern. When
 * you extend your actor with this trait, you get handling for adding subscribed
 * actors, removing subscribed actors, and sending messages out to all subscribed
 * actors.
 *
 * Simply override the `[[highPriority]]`, `[[mediumPriority]]`, or
 * `[[lowPriority]]` handlers to do your own message processing. Then, when you
 * want to update all subscribers, just call the `[[updateListeners]]`
 * method. The `[[createUpdate]]` method is used to generate the message that
 * you want sent to all subscribers.
 *
 * Note that the `[[AddAListener]]` and `[[RemoveAListener]]` messages (for
 * subscription control) are processed after any `highPriority` or
 * `mediumPriority` messages are processed, so take care to avoid overly broad
 * matches in those handlers that might consume internal messages.
 *
 * For example, you could write a simple service to provide clock ticks using
 * the following code:
 *
 * {{{
 * case object Tick
 *
 * object Ticker extends ListenerManager with LiftActor {
 *   import net.liftweb.util.ActorPing
 *
 *   // Set up the initial tick
 *   ActorPing.schedule(this, Tick, 1000L)
 *
 *   // This is a placeholder, since we're only interested
 *   // in Ticks
 *   def createUpdate = "Registered"
 *
 *   override def mediumPriority = {
 *     case Tick =>
 *       sendListenersMessage(Tick)
 *       ActorPing.schedule(this, Tick, 1000L)
 *   }
 * }
 * }}}
 *
 * There is also a helper, `[[CometListener]]`, for easily subscribing comets to
 * a `ListenerManager`. For this example, a client `CometActor` could look like:
 *
 * {{{
 * class CometClock extends CometListener {
 *   val registerWith = Ticker
 *
 *   ... handling code ...
 * }
 * }}}
 *
 * @see CometListener
 */
trait ListenerManager {
  self: SimpleActor[Any] =>

  import ListenerManager._

  /**
   * This is the list of all registered actors
   */
  private var listeners: List[ActorTest] = Nil

  /**
   * The main message handler; if you override it, you must invoke
   * `[[listenerService]]` at some point if you want to use the built-in
   * handling for `[[AddAListener]]` and `[[RemoveAListener]]`.
   *
   * By default, tries high, then medium priority, then the built-in listener
   * service, then low priority handlers.
   */
  protected def messageHandler: PartialFunction[Any, Unit] =
    highPriority orElse mediumPriority orElse
      listenerService orElse lowPriority

  /**
   * Provides built-in handling for listener addition/removal messages.
   */
  protected def listenerService: PartialFunction[Any, Unit] = {
    case AddAListener(who, wantsMessage) =>
      val pair = (who, wantsMessage)
      listeners ::= pair

      updateListeners(pair :: Nil)

    case RemoveAListener(who) =>
      listeners = listeners.filter(_._1 ne who)

      if (listeners.isEmpty) {
        onListenersListEmptied()
      }
  }

  /**
   * Called after a `[[RemoveAListener]]` message is processed and no more
   * listeners exist. Defaults to nothing.
   */
  protected def onListenersListEmptied(): Unit = {
  }

  /**
   * Update the provided `listeners` with the message generated by
   * `[[createUpdate]]`. If `listeners` is not provided, defaults to all the
   * listeners of this `ListenerManager`.
   *
   * Note that `listeners` is a list of `[[ActorTest]]`, which is a pair of
   * actor to partial function indicating whether that actor should receive a
   * given message.
   */
  protected def updateListeners(listeners: List[ActorTest] = listeners) {
    val update = createUpdate

    listeners foreach {
      case (who, wantsMessage) if wantsMessage.isDefinedAt(update) && wantsMessage(update) =>
        who ! update
    }
  }

  /**
   * Send a message we create to all of the listeners. Note that with this
   * invocation the `[[createUpdate]]` method is not used; instead, the message
   * is provided directly, and all listeners receive it regardless.
   */
  protected def sendListenersMessage(msg: Any) {
    listeners foreach (_._1 ! msg)
  }

  /**
   * This method is called when the `[[updateListeners]]` method needs a message
   * to send to subscribed actors. At minimum, `[[createUpdate]]` is used to
   * create the first message that a newly subscribed `[[CometListener]]` will
   * receive.
   */
  protected def createUpdate: Any

  /**
   * Override this method to process high priority messages. Note: ''you must
   * not process messages with a wildcard (match all)'', since this will
   * intercept the messages used for subscription control. Wildcard handling can
   * be done safely in `[[lowPriority]]`.
   */
  protected def highPriority: PartialFunction[Any, Unit] = Map.empty

  /**
   * Override this method to process medium priority messages. Like
   * `[[highPriority]]`, ''you must not process messages with a wildcard (`case
   * _`)'', since this will intercept the messages used for subscription
   * control. Wildcard handling can be done safely in `[[lowPriority]]`.
   */
  protected def mediumPriority: PartialFunction[Any, Unit] = Map.empty

  /**
   * Override this method to process low priority messages.
   */
  protected def lowPriority: PartialFunction[Any, Unit] = Map.empty
}
object ListenerManager {
  type ActorTest = (SimpleActor[Any], PartialFunction[Any, Boolean])
}

/**
 * This trait adds functionality to automatically register with a given
 * actor using `[[AddAListener]]` and `[[RemoveAListener]]` control
 * messages. The most typical usage would be to register with an instance of
 * `[[ListenerManager]]`.  You will need to provide a def/val for the
 * `[[registerWith]]` member to control which actor to connect to.
 *
 * See `[[ListenerManager]]` for a complete example.
 */
trait CometListener extends BaseCometActor {
  self: BaseCometActor =>

  /**
   * This controls which Actor to register with for updates. Typically this will
   * be an instance of `[[ListenerManager]]`, although you can provide your own
   * subscription handling on top of any `[[SimpleActor]]`.
   */
  protected def registerWith: SimpleActor[Any]

  abstract override protected def localSetup() {
    registerWith ! AddAListener(this,  { case _ => true })
    super.localSetup()
  }

  abstract override protected def localShutdown() {
    registerWith ! RemoveAListener(this)
    super.localShutdown()
  }
}


/**
 * A `[[LiftActorJ]]` with `[[ListenerManager]]`. Subclass this class to get a
 * Java-usable `LiftActorJ` with `ListenerManager` functionality.
 */
abstract class LiftActorJWithListenerManager extends LiftActorJ with ListenerManager {
  protected override def messageHandler: PartialFunction[Any, Unit] =
    highPriority orElse mediumPriority orElse
      listenerService orElse lowPriority orElse _messageHandler
}

